readonly members are not implicitly static, and therefore the static keyword can be applied to a readonly field explicitly if required.
A readonly field can be initialized either at the declaration or in a constructor, readonly fields can have different values depending on the constructor used.
Readonly can be applied to reference type since it's resolved at run-time; you can make struct and class instances readonly as well. For example:
Since readonly fields are not limited to values that can be determined at compile-time, this means that they are not substituted where they are used at compile-time but are the same as other variable lookups. This means that you won't have a situation like with const where a class library can change a const and another assembly using it won't get the updated value.
It must have a set value by the time constructor exits
A readonly gives a level of safety higher than const for constants that are subject to change over time. So, things that are truly const (days per week, etc.) can be safely made const because they never, ever change. But things that may be constant now but could conceivably change in the future due to changes in requirement or policy should be made readonly instead, especially if they are visible from other assemblies.
Because readonly fields are looked up at run-time, they are also slightly less efficient than compile-time const. But this performance gain is negligible and you should choose safety over performance.
If your readonly field is a value type (primitive or struct) or is immutable (the type that can't be changed once assigned like string), that field will behave like a constant.
Use readonly when the constant is a struct, a non-string, non-null class, cannot be determined at compile-time, or the constant is instance-level (instead of static).
readonly is evaluated when the instance is created
A readonly member can hold a complex object by using the new keyword at initialization.
One final thing that makes readonly nice is that it can be applied to instance members as well as class (static) members. This means that you can provide a constant that applies to all instances of the class, or just to the current instance.